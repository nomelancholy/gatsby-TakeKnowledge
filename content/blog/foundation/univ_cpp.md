---
title: 'C++ 프로그래밍 - '
date: 2020-9-20 20:55:13
category: 'foundation'
draft: true
---

한국 방송 통신 대학교 C++ 프로그래밍 강의를 듣고 공부한 내용을 제 언어로 다시 정리한 포스팅입니다.

## C++ 언어의 소개

### C++ 언어의 개요

#### C와 C++

C++은 C언어를 확장하여 만든 객체지향 프로그래밍 언어이다. 따라서 C가 가지고 있는 모든 기능이 C++에 포함되어 있으며 몇가지 예외를 제외하곤 C의 문법을 따른다. 또한 C와 같이 절차적으로 프로그래밍 할수도 있으며 클래스 등을 활용해 객체지향 프로그래밍도 가능하다.

#### C++의 표준

C++은 89년 처음 표준화 작업에 착수해 98년 첫 표준안이 나왔다(C++98). 이후 2003년에 사소한 오류를 바로 잡은 버전이 나왔고 (C++03) 2007년에는 C++03의 표준 라이브러리를 확장한 C++07 이 나왔다.

이후 2011년에 언어와 라이브러리 모두에서 상당한 개선이 이루어진 C++11이 나왔고 이러한 표준 개정 작업은 지속되어 2014년엔 C++14가, 2017년에는 C++17이 나왔다.

### C++ 프로그래밍의 작성 및 빌드

#### 소스 프로그램의 작성

C++ 프로그램의 소스 파일에는 소스 프로그램 파일과 헤더 파일이 있습니다.

소스 프로그램 파일은 일반적으로 .cpp를 확장자로 가지며 C++ 프로그램 명령어들을 포함하는 프로그램이 작성된 파일을 말합니다.

헤더 파일은 프로그램의 규모가 커지거나 여러 프로그래머가 프로그램을 분담하여 작성할 경우 여러 소스 프로그램에 공통적으로 들어가야 하는 부분을 별도로 한 곳에서 정의한 파일로 .h를 확장자로 가집니다. 이는 단독으로 컴파일 되지 않고 #include라는 선행처리기 지시어에 의해 소스 프로그램에 삽입되어 함께 컴파일 됩니다. 우리가 직접 작성하지 않은 라이브러리도 이와 같은 방식으로 C++ 컴파일러에서 헤더 파일로 제공하고 있습니다.

하나의 소스 프로그램과 그 파일에 삽입되는 헤더 파일들을 묶어 번역 단위(translation unit)라고 합니다. 하나의 프로그램은 한 개 이상의 번역 단위로 구성됩니다.

#### 프로그램의 빌드

C++ 프로그램의 실행 과정은 다음과 같습니다. 먼저 소스 프로그램에 include 되어 있는 헤더 파일의 내용이 삽입되고 그것이 obj 확장자를 갖는 목적 파일로 변환됩니다. 이후 링커(linker)가 그 파일에서 사용된 라이브러리들을 연결하고 목적 파일들을 합치는 빌드 과정을 거쳐 하나의 실행 파일을 만듭니다.

### C++ 프로그래밍 첫걸음

## C++ 언어의 기초

### 키워드와 식별자

### 기본 자료형 및 상수와 변수

### 연산자

### 자료형의 변환

### 흐름제어 구문

### 구조체와 클래스

#### 구조체

구조체는 하나의 대상물을 표현하기 위해 필요한 데이터 항목들을 묶어 하나의 단위로 표현할 수 있도록 해주는 사용자 정의 자료형을 의미합니다. struct 명령어를 사용해 선언할 수 있습니다. C++의 구조체는 함수를 함께 정의할 수도 있습니다.

#### 클래스

표현하고자 하는 대상의 데이터(데이터 멤버)와 이에 필요한 동작(멤버 함수)을 정의해놓은 객체의 설계도 입니다.

### 배열, 포인터, 참조

#### 포인터

포인터란 다른 변수, 구조체, 객체 등을 가리키는 변수로서 메모리의 주소와 직접적으로 연관됩니다.

자료형 뒤 명칭 앞에 \*를 사용하여 선언하면 그 포인터 변수는 자료형 값이 담긴 메모리 주소를 받는 포인터 변수가 됩니다.

#### 참조

## 함수

### 함수의 정의와 호출

### 인수의 전달

#### 값 호출

값 호출은 실 매개변수의 값을 형식 매개변수에 복사하여 주는 방식입니다. 이 방식을 통해 값이 형식 매개변수에 전달되면 형식 매개변수와 실 매개변수는 별개의 것이 되므로 형식 매개변수의 값을 변경하더라도 실 매개 변수의 값은 영향을 받지 않습니다. 값을 넘겨준 실 매개변수가 가리키는 메모리와 값을 복사받은 형식 매개변수가 가르키는 메모리가 다르기 때문입니다.이는 장점이 되기도 하지만 구조체와 같이 비교적 많은 양의 데이터를 포함하고 있는 인수를 전달할 때에는 데이터를 복사하는 양이 많아지고 메모리의 소비량도 많아집니다. 또한 형식 매개변수의 값을 변화시킬 때 실 매개변수 값이 변경되는 것이 필요한 경우도 있습니다. 이 때문에 참조 호출이 존재합니다.

#### 참조 호출

참조 호출은 실 매개변수의 참조, 즉 주소를 전답합니다. 이 때 실매개변수와 형식 매개변수의 자료형은 일치해야 하고 상수 참조가 아니라면 참조하는 것은 l-value 여야 합니다. 이렇게 되면 실 매개변수의 메모리와 형식 매개변수의 메모리가 같아지기 때문에 형식 매개변수의 값이 변경되면 실 매개변수의 값도 변경됩니다. 참조 호출을 하더라도 이런 형식 매개변수에서 실 매개변수를 수정할 수 없게 하고 싶다면 형식 매개변수를 const로 지정해 보호할 수 있습니다.

#### const 매개변수

### 함수의 다중정의

### inline 함수

## 클래스와 객체

### 객체지향 프로그래밍의 주요 개념

### 클래스 선언과 객체 정의

### 생성자와 소멸자

#### 생성자

생성자는 객체가 생성될 때 수행할 작업을 정의하는 특수한 멤버함수로서 객체를 정의한느 문장에 의해 자동적으로 호출됩니다.

생성자는 클래스의 이름을 사용하여 선언하고 반환 자료형을 표시하지 않으며 public 으로 선언한 생성자만 클래스 외부에서 객체를 만드는 데 사용할 수 있습니다.

이를 활용해 객체 생성시 반드시 초기화 되어야 하는 값을 자동으로 초기화 할 수 있는 등의 이점을 얻을 수 있습니다.

생성자 함수의 머리에 :을 기입하고 `변수명{초기값}, ...` 의 형태로 초기화 리스트를 나열하면 객체 생성시 해당 값들의 초기화가 이루어집니다.

#### 소멸자

소멸자는 객체가 소멸될 때 자동으로 실행되는 함수로서, 객체의 소멸에 따라 필요한 처리를 하기 위한 코드가 포함됩니다.

소멸자는 클리스의 이름 앞에 ~를 붙여 선언하고 어떤 값을 반환하거나 매개변수를 포함할 수 없으며 다중정의할 수 없습니다.

### 생성자의 종류

생성자는 어떠한 매개변수를 이용하여 객체를 초기화할 것인가에 따라 여러개를 다중 정의할 수 있습니다. 종류로는 디폴트 생성자, 복사 생성자, 이동 생성자가 있습니다.

#### 디폴트 생성자

매개변수가 없거나 모든 배개변수에 디폴트 인수가 지정된 생성자를 의미합니다. 클래스를 선언할 때 생성자를 선언하지 않으면 컴파일러가 묵시적으로 만들어주는 생성자입니다. 그러나 개발자가 디폴트 생성자가 아닌 생성자를 만든다면 디폴트 생성자는 묵시적으로 선언되지 않습니다.

#### 복사 생성자

같은 클래스의 객체를 복사하여 새로운 객체를 만드는 생성자입니다. 만일 복사 생성자를 명시적으로 선언하지 않으면 컴파일러가 이를 자동으로 만듭니다. 복사 생성자를 이용해 객체를 생성하면 인수로 들어온 객체의 데이터 멤버를 1:1로 복사해 객체를 생성합니다.

이를 명시적으로 생성할 때는 형식 매개변수를 그 클래스의 참조형으로 선언해야 합니다. 그렇지 않고 값 호출 방식으로 인수를 전달받게 되면 복사를 하기 위해 인스턴스를 하나 더 생성하는 모순이 발생하기 떄문입니다.

#### 이동 생성자

r-value는 단순 대입 연산자의 오른쪽 항을 말합니다. 이동 생성자는 이런 r-value 참조로 전달된 같은 클래스 객체의 내용을 이동하여 객체를 만드는 생성자입니다. 실 매개변수 값이 이동되기 때문에 const 매개변수는 사용할 수 없습니다. 값을 이동시켜준 r-value 객체는 이제 필요가 없기 때문에 이동 생성자 내부에선 이 r-value 객체가 가리키고 있는 메모리 부분을 초기화 하는 작업을 합니다.

### static 데이터 멤버와 static 멤버함수

### 클래스의 활용

## 연산자 다중정의

### 연산자 다중정의란

### 단항 연산자의 다중정의

### 이항 산술 연산자 및 관계 연산자의 다중정의

### 스트림 입출력 연산자의 다중정의

### 대입 및 이동 대입 연산자

### [] 연산자의 다중정의

### 문자열 클래스

### 자료형의 변환

### 연산자 다중정의의 주의 사항

## 상속

### 기초 클래스와 파생 클래스

### 파생 클래스의 생성자 및 소멸자

### 엑세스 제어

### 파생 클래스와 포인터

### 가상함수

### 추상 클래스

### 다중상속

## 템플릿

### 컨테이너 클래스와 템플릿

### 클래스 템플릿

### 함수 템플릿

### 표준 템플릿 라이브러리

## 예외처리

### 예외의 개념

### C++ 언어의 예외처리 체계

### 예외처리 클래스

### 예외처리 클래스의 상속

## 입출력 스트림

### 입출력 스트림의 개요

### cin을 이용한 입력

### cout을 이용한 출력

### 파일 입출력
