---
title: '자료구조 - '
date: 2020-9-20 20:55:13
category: 'foundation'
draft: true
---

## 자료구조란 무엇인가

### 자료와 정보의 관계

자료와 정보는 쌀과 밥의 관계라고 할 수 있습니다. 수집, 측정, 관찰 등을 통해 수집한 자료를 사용자에게 좀 더 적합한 형태로 처리하면 정보가 됩니다.

### 추상화의 개념

추상화란 다양한 특성을 가지고 있어 세세하게는 다를 수 있는 서로 다른 객체들을 그것들이 공통적으로 가지고 있는 특정 개념을 이용하여 같은 종류의 묶음으로 정의하는 것 입니다. 예를 들자면 외관상으로는 다른 부분이 있더라도 여러 명의 사람들을 실어나르는 큰 차들을 모두 버스라고 부르는 것도 추상화가 이루어졌기에 가능한 일입니다.

### 자료구조의 개념

이런 추상화는 객체라면 어디에든 적용할 수 있고 자료 역시 추상화할 수 있습니다. 자료구조는 이렇게 자료를 추상화하여 그 논리적 관계를 구체화 한 것을 말합니다. 이런 자료구조는 프로그래밍 언어에서 제공하는 '미리 정의된 자료구조'와 개발자가 정의하여 사용하는 '사용자 정의 자료 구조'로 나눌 수 있고 '미리 정의된 자료구조'는 다시 '기본 자료구조'와 '파생된 자료구조'로 나눌 수 있습니다. 기본 자료구조로는 정수, 실수, 문자 등이 있고 파생된 자료구조로는 구조체, 배열, 포인터등이 있으며 사용자 정의 자료 구조로는 스택, 큐, 리스트, 트리, 그래프 등이 있습니다.

### 자료구조와 알고리즘의 관계 및 알고리즘의 특성

### 알고리즘 성능의 분석과 측정

#### 알고리즘 실행 시간의 예측

#### 실행 메모리의 예측

#### 실행 시간의 측정

## 배열

### 배열의 정의

### 배열 추상 자료형

### 배열의 연산의 구현

### 1차원 배열

### 배열의 확장

### 희소행렬의 개념

## 스택

### 스택의 개념

스택은 위쪽 한 방향으로만 물건을 넣고 뺄 수 있는 박스와 같은 형태의 자료 구조입니다. 그렇기 때문에 데이터가 넣은 순서대로 쌓이고 뺄 때도 나중에 넣은 걸 먼저 빼야 합니다. 이런 특성을 LIFO (Last in first out, 후입선출) 라고 합니다. 스택에서 대표적으로 사용되는 연산은 스택에 데이터를 넣는 push와 스택에서 데이터를 삭제하는 pop, 그리고 스택이 가득 찼는지를 확인하는 isFull 이 있습니다. 스택에는 top이라는 포인터 변수가 있어 가장 나중에 들어온 데이터 부분을 가리키고 있는데 (스택이 비어있을 때는 스택의 가장 아래 부분을 가리키고 있습니다.) push 명령이 발생하면 top 포인터 변수가 가리키고 있는 곳 하나 위쪽 부분에 데이터를 넣은 다음 포인터 변수를 1 증가시키고 반대로 pop 연산이 발생하면 top 포인터 변수가 가리키고 있는 부분의 데이터를 삭제하고 포인터 변수를 1 감소 시킵니다. 스택의 저장공간은 유한한데 (스택의 사이즈는 스택 생성시 정할 수 있습니다) 스택이 가득 차있는 경우에 push 명령이 발생하면 스택이 가득 찼다는 메시지를 출력되고 데이터의 추가 삽입이 이루어지지 않습니다. 이렇게 스택이 가득 차 있는지를 확인할 수 있는 연산인 isFull 이고 스택이 가득 차 있다면 True 값을, 가득 차 있지 않다면 False 값을 반환합니다. 스택을 구현하는 여러 가지 방법들이 있지만 대표적으로는 배열을 활용해 구현할 수 있습니다. 이렇게 구현한 스택은 LIFO의 특성을 활용해 변수에 대한 메모리의 할당과 수집을 위한 시스템 스택, 서브루틴의 수행이 끝난 후 되돌아갈 함수 주소를 저장하기 위한 서브루틴 호출 관리, 연산자들 간의 우선순위에 의해 계산 순서가 결정되는 수식 계산, 프로그램 수행 도중 발생되는 인터럽트 처리와 되돌아갈 명령 수행 지점 저장 등에 사용됩니다.

### 스택의 추상 자료형

### 스택의 응용

- 서브루틴 함수 호출 관리

프로그램이 메인 함수 하나만으로 구성되는 경우는 드뭅니다. 여러 개의 서브루틴 함수로 나뉘어서 이를 필요할 때마다 호출해가며 프로그램을 진행되는 경우가 대부분입니다. 이런 서브루틴 함수 호출 관리를 위해 스택이 사용됩니다. 방법은 아래와 같습니다.

예를 들어 메인 함수 진행중에 A 함수를 호출한다면 메인 함수가 호출될 때 push된 스택의 메인 함수 부분에 A 함수 호출이 끝나고 이어서 진행해야 할 부분의 위치를 저장합니다. 이는 A함수의 내용을 순차적으로 실행해가다가 B 함수를 호출한다해도 마찬가지 입니다. A함수가 호출될 때 스택의 메인 함수 위로 push되어 생성된 A함수 영역에 B함수의 호출이 끝나면 실행되어야 하는 부분의 위치를 저장 합니다. 이렇게 하면 호출한 함수가 동작을 모두 마쳤을 때 스택에 저장한 위치부터 이어서 동작을 실행하면 되고 스택의 특성상 나중에 생긴 영역이 실행되고 삭제되는 것은 보장되기 때문에 순서를 관리하는 측면에서 봐도 효율적으로 서브루틴 함수 호출 관리를 할 수 있습니다.

### 스택의 연산

#### 스택의 삭제 연산

#### 스택의 삽입 연산

### 배열을 이용한 스택의 구현

#### 스택의 삭제 연산

#### 스택의 삽입 연산

### 사칙연산식의 전위/후위/중위 표현

#### 전위 표기법

#### 후위 표기법

#### 스택을 이용한 후위 표기식의 계산

#### 후위 표기식의 계산 알고리즘과 설명

## 큐

### 큐의 개념

### 큐의 추상 자료형

### 큐의 응용

### 배열을 이용한 큐의 구현

#### 큐의 삽입 연산

#### 큐의 삭제 연산

### 원형 큐

## 연결 리스트

### 리스트의 개념

### 배열을 이용한 리스트의 구현

### 포인터를 이용한 리스트의 구현

### 포인터 변수

#### 구조체 포인터 타입

#### 프로그램 싱행 중의 구조체 메모리 할당

### 연결 리스트에서 노드의 삽입과 삭제

### 연결 리스트의 여러 가지 연산 프로그램

#### 연결 리스트의 생성

#### 연결 리스트의 노드 삽입

#### 연결 리스트의 노드 삭제

#### 연결 리스트의 특정 노드 뒤에 삽입

#### 연결 리스트의 특정 노드 검색

## 연결 리스트의 응용

### 연결 리스트의 변형

### 원형 연결 리스트

#### 원형 연결 리스트의 생성

#### 원형 연결 리스트의 노드 삽입

#### 원형 연결 리스트의 노드 삭제

### 이중 연결 리스트

#### 이중 연결 리스트의 노드 구조

#### 이중 연결 리스트의 노드 삽입

#### 이중 연결 리스트의 노드 삭제

## 트리

### 트리

### 용어와 논리적 표현 방법

### 추상 자료형

### 이진 트리

#### 이진 트리 개요

#### 이진 트리 구현

### 이진 트리 연산

#### 이진 트리 순회

#### 이진 트리 생성, 삽입, 삭제

#### 이진 트리 노드 개수 세기

### 일반 트리를 이진 트리로 변환

## 스레드 트리

### 스레드 트리

### 스레드 트리 구현

### 스레드 트리 순회, 삽입, 삭제

#### 스레드 트리 순회

#### 스레드 트리 노드 삽입 및 삭제

## 힙

### 우선 순위 큐

### 힙 추상 자료형

### 힙에서 삭제 및 삽입 연산

## 선택트리, 숲, 이진트리 개수

### 선택트리

### 숲

### 이진 트리 개수

## BS, Splay, AVL, BB

### 이진 탐색 트리 (BS 트리)

#### BS 트리 순회

#### BS 트리 탐색

#### BS 트리 삽입 및 삭제

### Splay, AVL, BB 트리

#### Splay 트리

#### AVL 트리

#### BB 트리

## 멀티웨이 탐색 트리

### m원 탐색 트리

### B 트리

#### B 트리의 노드 삽입

#### B 트리의 노드 삭제

### B\* 트리, B+ 트리

#### B\* 트리

#### B+ 트리

### 2-3 트리

#### 2-3 트리의 탐색

#### 2-3 트리의 삽입 및 삭제

### 2-3-4 트리

### 레드 블랙 트리

## 그래프

### 개념 및 용어

### 추상 자료형

### 그래프 표현법

#### 인접 행렬에 의한 그래프 표현

#### 인접 리스트에 의한 그래프 표현

### 그래프 탐색

#### 깊이 우선 탐색

#### 너비 우선 탐색

### 최소 신장 트리

#### 프림 알고리즘

#### 크루스컬 알고리즘

#### 솔린 알고리즘
